#!/usr/bin/env python
# xfail-license

# This creates the tables used for distributions implemented using the
# ziggurat algorithm in `core::rand::distributions;`. They are
# (basically) the tables as used in the ZIGNOR variant (Doornik 2005).
# They are changed rarely, so the generated file should be checked in
# to git.
#
# It creates 3 tables: X as in the paper, F which is f(x_i), and
# F_DIFF which is f(x_i) - f(x_{i-1}). The latter two are just cached
# values which is not done in that paper (but is done in other
# variants). Note that the adZigR table is unnecessary because of
# algebra.
#
# It is designed to be compatible with Python 2 and 3.

from math import exp, sqrt, log, floor
import random

# The order should match the return value of `tables`
TABLE_NAMES = ['X', 'F', 'F_DIFF']

# The actual length of the table is 1 more, to stop
# index-out-of-bounds errors. This should match the bitwise operation
# to find `i` in `zigurrat` in `libstd/rand/mod.rs`. Also the *_R and
# *_V constants below depend on this value.
TABLE_LEN = 256

# equivalent to `zigNorInit` in Doornik2005, but generalised to any
# distribution. r = dR, v = dV, f = probability density function,
# f_inv = inverse of f
def tables(r, v, f, f_inv):
    # compute the x_i
    xvec = [0]*(TABLE_LEN+1)

    xvec[0] = v / f(r)
    xvec[1] = r

    for i in range(2, TABLE_LEN):
        last = xvec[i-1]
        xvec[i] = f_inv(v / last + f(last))

    # cache the f's
    fvec = [0]*(TABLE_LEN+1)
    fdiff = [0]*(TABLE_LEN+1)
    for i in range(TABLE_LEN+1):
        fvec[i] = f(xvec[i])
        if i > 0:
            fdiff[i] = fvec[i] - fvec[i-1]

    return xvec, fvec, fdiff

# Distributions
# N(0, 1)
def norm_f(x):
    return exp(-x*x/2.0)
def norm_f_inv(y):
    return sqrt(-2.0*log(y))

NORM_R = 3.6541528853610088
NORM_V = 0.00492867323399

NORM = tables(NORM_R, NORM_V,
              norm_f, norm_f_inv)

# Exp(1)
def exp_f(x):
    return exp(-x)
def exp_f_inv(y):
    return -log(y)

EXP_R = 7.69711747013104972
EXP_V = 0.0039496598225815571993

EXP = tables(EXP_R, EXP_V,
             exp_f, exp_f_inv)


# Output the tables/constants/types

def render_static(name, type, value):
    # no space or
    return 'pub static %s: %s =%s;\n' % (name, type, value)

# static `name`: [`type`, .. `len(values)`] =
#     [values[0], ..., values[3],
#      values[4], ..., values[7],
#      ... ];
def render_table(name, values, ty):
    rows = []
    # 4 values on each row
    for i in range(0, len(values), 4):
        row = values[i:i+4]
        rows.append(', '.join('%.18f' % f for f in row))

    rendered = '\n    [%s]' % ',\n     '.join(rows)
    return render_static(name, '[%s, .. %d]' % (ty, len(values)), rendered)


with open('ziggurat_tables.rs', 'w') as f:
    f.write('''// Copyright 2013 The Rust Project Developers. See the COPYRIGHT
// file at the top-level directory of this distribution and at
// http://rust-lang.org/COPYRIGHT.
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

// Tables for distributions which are sampled using the [ziggurat
// algorithm](https://en.wikipedia.org/wiki/Ziggurat_algorithm). Autogenerated
// by `ziggurat_tables.py`.

// The version used here is ZIGNOR [Doornik 2005, "An Improved
// Ziggurat Method to Generate Normal Random Samples"] which is slower
// (about double, it generates an extra random number) than the
// canonical version [Marsaglia & Tsang 2000, "The Ziggurat Method for
// Generating Random Variables"], but more robust. If one wanted, one
// could implement VIZIGNOR the ZIGNOR paper for more speed.

use Rng;
pub type ZigTable32 = &\'static [f32, .. %d];
pub type ZigTable64 = &\'static [f64, .. %d];

// inlining should mean there is no performance penalty for this
#[inline(always)]
pub fn ziggurat<R:Rng>(rng: &mut R,
                       center_u: bool,
                       X: ZigTable64,
                       F: ZigTable64,
                       F_DIFF: ZigTable64,
                       pdf: &fn(f64) -> f64, // probability density function
                       zero_case: &fn(&mut R, f64) -> f64) -> f64 {
    loop {
        let u = if center_u {2.0 * rng.gen() - 1.0} else {rng.gen()};
        let i: uint = rng.gen::<uint>() & 0xff;
        let x = u * X[i];

        let test_x = if center_u {x.abs()} else {x};

        // algebraically equivalent to |u| < X[i+1]/X[i] (or u < X[i+1]/X[i])
        if test_x < X[i + 1] {
            return x;
        }
        if i == 0 {
            return zero_case(rng, u);
        }
        // algebraically equivalent to f1 + DRanU()*(f0 - f1) < 1
        if F[i+1] + F_DIFF[i+1] * rng.gen() < pdf(x) {
            return x;
        }
    }
}
'''  % (TABLE_LEN + 1, TABLE_LEN + 1))

    for name, tables, r in [('NORM', NORM, NORM_R),
                            ('EXP', EXP, EXP_R)]:
        f.write(render_static('ZIG_%s_R_32' % name, 'f32', ' %.18f' % r))
        f.write(render_static('ZIG_%s_R_64' % name, 'f64', ' %.18f' % r))
        for (tabname, table) in zip(TABLE_NAMES, tables):
            f.write(render_table('ZIG_%s_%s_32' % (name, tabname), table, 'f32'))
            f.write(render_table('ZIG_%s_%s_64' % (name, tabname), table, 'f64'))
