#[allow(unused_imports)];

extern mod rand;
use std::*;
use std::num::Zero;
use rand::*;
use rand::rng::*;
use rand::rng::isaac::*;
use rand::rng::mersenne_twister::*;
use rand::rng::xorshift::*;
use rand::rng::lcg::*;
use rand::rng::lfsr::*;
use rand::rng::mwc::*;

trait Runner {
    fn run<R: Rng>(&self, R, uint);
}

struct SumN { n: uint }

impl Runner for SumN {
    fn run<R: Rng>(&self, mut rng: R, bits: uint) {
        macro_rules! go(
            ($ty:ty) => {{
                let mut sum: $ty = num::Zero::zero();

                for self.n.times {
                    sum += rng.gen();
                }
                println(fmt!("%?", sum));
            }}
        );
        if bits == 32 {
            go!(u32)
        } else {
            go!(u64)
        }
    }
}

// Dumps binary data to stdout. Some(n) for `n` MiB, None for a lot.
struct DumpRaw { megabytes: Option<uint> }

impl Runner for DumpRaw {
    fn run<R: Rng>(&self, mut rng: R, bits: uint) {
        macro_rules! go(
            ($ty:ty) => {{
                let mut buffer: ~[$ty] = vec::from_elem(8*(1 << 20)/bits, 0); // 1 MB

                // -1 is approximately infinity
                for self.megabytes.get_or_default(-1 as uint).times {
                    for vec::each_mut(buffer) |elem| {
                        *elem = rng.gen();
                    }

                    io::stdout().write(unsafe { cast::transmute::<&[$ty], &[u8]>(buffer) });
                }
            }}
        );
        if bits == 32 {
            go!(u32)
        } else {
            go!(u64)
        }
    }
}

fn str_to_rng<R: Runner>(name: &str, r: R) {
    macro_rules! go(
        ($name:ident) => {}
    );

    macro_rules! matches(
        ($($name:ident: $bits:expr),*) => {
            $(if name == stringify!($name) {
                println(stringify!($name));
                let __rng: $name = Rng::new();
                r.run(__rng, $bits);
            } else)*
                {
                    fail!("unrecognised RNG `%s`")
                }
        }
    )

    matches!(Isaac: 32, Isaac64: 64,
             MT19937: 32, MT19937_64: 64,
             WELL512: 32,
             XorShift4: 32,
             LFSR258: 64, LFSR113: 32, Taus88: 32,
             StdRng: 64,
             MinStd_Rand: 32, Rand48: 32,
             CMWC: 32, MWC256: 32)
}

fn main() {
    let mut args = os::args();
    let prog_name = args.shift();
    // argument parsing!
    match args {
        [~"sum", r, .. rest] => {
            let count = rest.head_opt().chain(|&x| uint::from_str(x)).get_or_default(100_000_000);
            str_to_rng(r, SumN { n: count });
        }
        [~"dump", r, .. rest] => {
            let count = rest.head_opt().chain(|&x| uint::from_str(x));
            str_to_rng(r, DumpRaw { megabytes: count });
        }
        _ => print_help(prog_name)
    }
}

fn print_help(program_name: &str) {
    println(fmt!(
        "%s dump RNG [N] - Dump N MiB of random output from RNG. (Infinite if omitted)
%s sum RNG [N] - Sum the first N random numbers generated by RNG. (100,000,000 if omitted)

RNG can be any of the ones implemented in the library.", program_name, program_name))
}